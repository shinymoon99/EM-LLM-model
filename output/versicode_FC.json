[
    {
        "id": "downstream_application_code_block_6",
        "answer": " <start>\n\n```python\nimport numpy as np\n\ndef flip_mask(mask):\n    total = np.sum(mask)\n    if len(mask) == total:\n        index = np.random.randint(len(mask))\n        mask[index] = 1 - mask[index]\n    return mask\n<end>",
        "ground_truth": "import numpy as np\n\ndef mask_safe(mask):\n    tot_len = mask.shape[0]\n    mask_cnt = np.sum(mask.astype(np.int32))\n    range_i = np.arange(tot_len)\n    \n    if tot_len == mask_cnt or mask_cnt == 0:\n        idx = np.random.choice(range_i)\n        mask[idx] = 1 - mask[idx]\n    \n    return mask"
    },
    {
        "id": "downstream_application_code_block_7",
        "answer": " <start>\ndef delete_noisy_char(s):\n    noisy_chars = ['[', ']', '(', ')', ',', '.', ':', '\"', \"'\", '\\\\', '/', '\\\\n']\n    for char in noisy_chars:\n        s = s.replace(char, '')\n    return s\n\ndef extend_vocab(vocab, token, vector):\n    if token not in vocab:\n        vocab[token] = vector\n</end>",
        "ground_truth": "import torch\n\ndef delete_noisy_char(s):\n    s = (\n        s.replace(\",\", \" \")\n        .replace(\"/\", \" \")\n        .replace('\"', \" \")\n        .replace(\"-\", \" \")\n        .replace(\";\", \" \")\n        .replace(\".\", \" \")\n        .replace(\"&\", \" \")\n        .replace(\"?\", \" \")\n        .replace(\"!\", \" \")\n        .replace(\"(\", \" \")\n        .replace(\")\", \" \")\n    )\n    s = s.strip()\n    return s\n\ndef extend_vocab(pretrained_vocab, token, vector):\n    pretrained_vocab.itos.extend([token])\n    pretrained_vocab.stoi[token] = pretrained_vocab.vectors.shape[0]\n    pretrained_vocab.vectors = torch.cat([pretrained_vocab.vectors, vector], dim=0)\n\n\n"
    },
    {
        "id": "downstream_application_code_block_8",
        "answer": " <start>\n\ndef args():\n    import sys\n    return ' '.join(sys.argv[1:])\n\n<end>",
        "ground_truth": "import psutil\nimport os\n\ndef get_command():\n    my_process = psutil.Process( os.getpid() )\n    return \" \".join(my_process.cmdline())"
    },
    {
        "id": "downstream_application_code_block_9",
        "answer": " <start>\n\n```python\nfrom setuptools import setup, Extension\nfrom io import open\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\nsubmodlib_module = Extension(\n    \"submodlib\",\n    sources=[\"submodlib.cpp\"],\n    language=\"c++\",\n    include_dirs=[\"path/to/submodlib/include\"],\n    libraries=[\"submodlib\"]\n)\n\nsetup(\n    name=\"submodlib\",\n    version=\"0.1.0\",\n    description=\"Efficient and scalable library for submodular optimization\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Your Name\",\n    author_email=\"your.email@example.com\",\n    url=\"https://github.com/yourusername/submodlib\",\n    license=\"MIT\",\n    packages=[\"submodlib\"],\n    ext_modules=[submodlib_module],\n    install_requires=[\n        \"pybind11==2.6.0\"\n    ]\n)\n<end>\n```\n\nPlease replace `\"path/to/submodlib/include\"` and `\"submodlib.cpp\"` with the actual paths to the C++ include directory and source file for the submodlib library. Also, replace `\"Your Name\"` and `\"your.email@example.com\"` with your own name and email address.",
        "ground_truth": "#from glob import glob\nfrom setuptools import find_packages, setup\n\n# try:\n#     from pybind11.setup_helpers import Pybind11Extension, build_ext\n# except ImportError:\n#     from setuptools import Extension as Pybind11Extension\n# The above\n# is not eeded any more because it is available at setup time due to pyproject.toml\n# this is why setup_requires is also not needed\n\nfrom pybind11.setup_helpers import Pybind11Extension, build_ext\n\nimport sys\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nexec(open('submodlib/version.py').read())\n\n#ParallelCompile(\"NPY_NUM_BUILD_JOBS\").install()\n\next_modules = [\n    Pybind11Extension(name=\"submodlib_cpp\",\n    sources=\n        [\"cpp/SetFunction.cpp\",\n        \"cpp/utils/helper.cpp\", \"cpp/wrappers/wr_helper.cpp\",\n        \"cpp/utils/sparse_utils.cpp\", \"cpp/wrappers/wr_sparse_utils.cpp\",\n        \"cpp/optimizers/NaiveGreedyOptimizer.cpp\", \n        \"cpp/optimizers/LazyGreedyOptimizer.cpp\", \n        \"cpp/optimizers/StochasticGreedyOptimizer.cpp\", \n        \"cpp/optimizers/LazierThanLazyGreedyOptimizer.cpp\", \n        \"cpp/wrappers/wrapper.cpp\", \n        \"cpp/submod/FacilityLocation.cpp\", \"cpp/wrappers/wr_FacilityLocation.cpp\", \n        \"cpp/submod/FacilityLocation2.cpp\", \"cpp/wrappers/wr_FacilityLocation2.cpp\", \n        \"cpp/submod/DisparitySum.cpp\", \"cpp/wrappers/wr_DisparitySum.cpp\", \n        \"cpp/submod/FeatureBased.cpp\", \"cpp/wrappers/wr_FeatureBased.cpp\", \n        \"cpp/submod/GraphCut.cpp\", \"cpp/wrappers/wr_GraphCut.cpp\", \n        \"cpp/submod/SetCover.cpp\", \"cpp/wrappers/wr_SetCover.cpp\", \n        \"cpp/submod/ProbabilisticSetCover.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCover.cpp\", \n        \"cpp/submod/DisparityMin.cpp\", \"cpp/wrappers/wr_DisparityMin.cpp\", \n        \"cpp/submod/LogDeterminant.cpp\", \"cpp/wrappers/wr_LogDeterminant.cpp\", \n        \"cpp/smi/FacilityLocationMutualInformation.cpp\", \"cpp/wrappers/wr_FacilityLocationMutualInformation.cpp\", \n        \"cpp/smi/FacilityLocationVariantMutualInformation.cpp\", \"cpp/wrappers/wr_FacilityLocationVariantMutualInformation.cpp\", \n        \"cpp/smi/ConcaveOverModular.cpp\", \"cpp/wrappers/wr_ConcaveOverModular.cpp\", \n        \"cpp/smi/GraphCutMutualInformation.cpp\", \"cpp/wrappers/wr_GraphCutMutualInformation.cpp\", \n        \"cpp/condgain/GraphCutConditionalGain.cpp\", \"cpp/wrappers/wr_GraphCutConditionalGain.cpp\", \n        \"cpp/condgain/ConditionalGain.cpp\", \n        \"cpp/condgain/FacilityLocationConditionalGain.cpp\", \"cpp/wrappers/wr_FacilityLocationConditionalGain.cpp\", \n        \"cpp/condgain/LogDeterminantConditionalGain.cpp\", \"cpp/wrappers/wr_LogDeterminantConditionalGain.cpp\", \n        \"cpp/condgain/ProbabilisticSetCoverConditionalGain.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCoverConditionalGain.cpp\", \n        \"cpp/smi/ProbabilisticSetCoverMutualInformation.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCoverMutualInformation.cpp\", \n        \"cpp/smi/MutualInformation.cpp\", \n        \"cpp/smi/LogDeterminantMutualInformation.cpp\", \"cpp/wrappers/wr_LogDeterminantMutualInformation.cpp\", \n        \"cpp/smi/SetCoverMutualInformation.cpp\", \"cpp/wrappers/wr_SetCoverMutualInformation.cpp\", \n        \"cpp/condgain/SetCoverConditionalGain.cpp\", \"cpp/wrappers/wr_SetCoverConditionalGain.cpp\", \n        \"cpp/cmi/FacilityLocationConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_FacilityLocationConditionalMutualInformation.cpp\", \n        \"cpp/cmi/LogDeterminantConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_LogDeterminantConditionalMutualInformation.cpp\", \n        \"cpp/cmi/SetCoverConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_SetCoverConditionalMutualInformation.cpp\", \n        \"cpp/cmi/ProbabilisticSetCoverConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCoverConditionalMutualInformation.cpp\", \n        \"cpp/Clustered.cpp\", \"cpp/wrappers/wr_Clustered.cpp\"],\n        extra_compile_args=['-O3'],\n        #include_dirs=[\"cpp/\"],\n        # Example: passing in the version to the compiled code\n        #sorted(glob(\"cpp/submod/*.cpp\")),\n        define_macros = [('VERSION_INFO', __version__)],\n        ),\n]\n\nsetup(\n    name='submodlib',\n    #packages=find_packages(include=['submodlib']),\n    packages=['submodlib', 'submodlib/functions'],\n    #packages=find_packages('submodlib'),\n    #package_dir={'':'submodlib'},\n    #version='0.0.2',\n    version=__version__,\n    description='submodlib is an efficient and scalable library for submodular optimization which finds its application in summarization, data subset selection, hyper parameter tuning etc.',\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author='Vishal Kaushal',\n    cmdclass={\"build_ext\": build_ext},\n    ext_modules=ext_modules,\n    author_email='vishal.kaushal@gmail.com',\n    url=\"https://github.com/vishkaush/submodlib\",\n    #url='http://pypi.python.org/pypi/submodlib/',\n    #url=\"https://github.com/pypa/sampleproject\",\n    license='MIT',\n    # install_requires=[\n    #     \"numpy >= 1.14.2\",\n    #     \"scipy >= 1.0.0\",\n    #     \"numba >= 0.43.0\",\n    #     \"tqdm >= 4.24.0\",\n    #     \"nose\"\n    # ],\n    install_requires=[\"numpy==1.22.0\", \"scipy\", \"scikit-learn\", \"numba\"],\n    #setup_requires=['pybind11','pytest-runner'],\n    tests_require=['pytest'],\n    #extras_require={\"test\": \"pytest\"},\n    test_suite='tests',\n    #classifiers=[\n    #    \"Programming Language :: Python :: 3\",\n    #    \"License :: OSI Approved :: MIT License\",\n    #    \"Operating System :: OS Independent\",\n    #],\n    zip_safe=False \n)\n"
    },
    {
        "id": "downstream_application_code_block_10",
        "answer": " <start>\n\n```python\nimport numpy as np\nfrom sklearn.metrics.pairwise import cosine_similarity, euclidean_distances\nfrom helper import create_kernel\n\ngroundData = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\ndef dot_kernel(X, Y):\n    return np.dot(X, Y.T)\n\ndef cosine_kernel(X, Y):\n    return np.array([[cosine_similarity(x, y) for y in Y] for x in X])\n\ndef euclidean_kernel(X, Y):\n    return np.array([[euclidean_distances(x, y) for y in Y] for x in X])\n\nmethods = [\"sklearn\", \"rowwise\", \"np\"]\nmetrics = [\"dot\", \"cosine\", \"euclidean\"]\n\nfor method in methods:\n    for metric in metrics:\n        if method == \"sklearn\":\n            if metric == \"cosine\":\n                kernel = cosine_kernel(groundData, groundData)\n            elif metric == \"euclidean\":\n                kernel = euclidean_kernel(groundData, groundData)\n        elif method == \"rowwise\":\n            if metric == \"dot\":\n                kernel = create_kernel(groundData, groundData, dot_kernel)\n            elif metric == \"cosine\":\n                kernel = create_kernel(groundData, groundData, cosine_kernel)\n            elif metric == \"euclidean\":\n                kernel = create_kernel(groundData, groundData, euclidean_kernel)\n        print(f\"Method: {method}, Metric: {metric}\\nKernel Matrix:\\n{kernel}\\n\")\n```\n\n<end>",
        "ground_truth": "import numpy as np\n#import submodlib_cpp as subcp\nimport submodlib.helper as helper\n\ngroundData =np.array( [(4.5,13.5), (5,13.5), (5.5,13.5)] )\n\n#methods = [\"sklearn\", \"fastdist\", \"scipy\", \"rowwise\", \"np\", \"np_numba\", \"other\"]\nmethods = [\"sklearn\", \"rowwise\", \"np\"]\n\nfor method in methods:\n    print(\"\\n***Kernel from \", method)\n    kernel = helper.create_kernel(groundData, metric=\"dot\", method=method)\n    print(kernel)\n\n# for method in methods:\n#     print(\"\\n***Kernel from \", method)\n#     kernel = helper.create_kernel(groundData, metric=\"cosine\", method=method)\n#     print(kernel)"
    }
]